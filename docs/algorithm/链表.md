
1. 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的
   ```mermaid
   flowchart LR
   
   1[1]-->2[2]-->3[3]
 
    ```
    ```mermaid
    flowchart LR
      1[1]-->3[3]-->4[4]
    ```

    输出:
    ```mermaid 
    flowchart LR
    1[1]-->1a[1]-->2[2]-->3[3]-->4[4]
    ```
    答:
    
    ```js
    class ListNode {
      constructor(val) {
        this.val = val;
        this.next = null;
      }
    }
    /**
     * 题目：将两个升序链表合并为一个新的升序链表并返回。
     * 新链表是通过拼接给定的两个链表的所有节点组成的。
     *
     * 思路：
     * 1. 创建一个新的链表用于存储合并后的结果。
     * 2. 遍历两个链表，将较小的节点加入到新链表中。
     * 3. 将剩余的节点加入到新链表的尾部。
     * 4. 返回新链表的头节点。
     *
     * 时间复杂度：O(m+n)，其中m和n分别为两个链表的长度。
     * 空间复杂度：O(1)
     *
     * @param {ListNode} l1 链表1
     * @param {ListNode} l2 链表2
     * @return {ListNode} 合并后的链表
     */
    function mergeTwoLists(l1, l2) {
      // 创建一个新链表用于存储合并后的结果
      const dummy = new ListNode(0);
      let tail = dummy;
    
      // 遍历两个链表，将较小的节点加入到新链表中
      while (l1 && l2) {
        if (l1.val <= l2.val) {
          tail.next = l1;
          l1 = l1.next;
        } else {
          tail.next = l2;
          l2 = l2.next;
        }
        tail = tail.next;
      }
    
      // 将剩余的节点加入到新链表的尾部
      tail.next = l1 || l2;
    
      // 返回新链表的头节点
      return dummy.next;
    }
    
    
    // 定义两个链表
    const l1 = new ListNode(1);
    l1.next = new ListNode(2);
    l1.next.next = new ListNode(4);
    
    const l2 = new ListNode(1);
    l2.next = new ListNode(3);
    l2.next.next = new ListNode(4);
    
    // 合并两个链表
    const mergedList = mergeTwoLists(l1, l2);
    
    // 打印合并后的链表
    let node = mergedList;
    const result = [];
    while (node) {
      result.push(node.val);
      node = node.next;
    }
    
    console.log(result); // [1, 1, 2, 3, 4, 4]
    ```

